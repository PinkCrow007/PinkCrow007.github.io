<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统课程设计--阅读xv6源码 | Hexo</title><meta name="keywords" content="操作系统"><meta name="author" content="Pink Crow"><meta name="copyright" content="Pink Crow"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统课程设计–阅读xv6源码操作系统课设作业——_跟MIT 6.S081课程读源码，写报告。 一、内存管理模型在main.c中，有kinit() kvminit()来初始化页表分配器，创建内核的页表。exec是一个创建进程地址空间的重要系统调用函数。 1. void kinit() (kernel&#x2F;kallo.c)kinit()函数设置页表分配器（page allocator）,也就是空闲页链">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统课程设计--阅读xv6源码">
<meta property="og:url" content="http://example.com/2021/08/26/%E9%98%85%E8%AF%BBxv6%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="操作系统课程设计–阅读xv6源码操作系统课设作业——_跟MIT 6.S081课程读源码，写报告。 一、内存管理模型在main.c中，有kinit() kvminit()来初始化页表分配器，创建内核的页表。exec是一个创建进程地址空间的重要系统调用函数。 1. void kinit() (kernel&#x2F;kallo.c)kinit()函数设置页表分配器（page allocator）,也就是空闲页链">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828003805755.png">
<meta property="article:published_time" content="2021-08-26T08:13:05.000Z">
<meta property="article:modified_time" content="2021-08-28T11:49:51.845Z">
<meta property="article:author" content="Pink Crow">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828003805755.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/08/26/%E9%98%85%E8%AF%BBxv6%E6%BA%90%E7%A0%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统课程设计--阅读xv6源码',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-28 19:49:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myfix.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828114334929.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828003805755.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统课程设计--阅读xv6源码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-26T08:13:05.000Z" title="发表于 2021-08-26 16:13:05">2021-08-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-28T11:49:51.845Z" title="更新于 2021-08-28 19:49:51">2021-08-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统课程设计--阅读xv6源码"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="操作系统课程设计–阅读xv6源码"><a href="#操作系统课程设计–阅读xv6源码" class="headerlink" title="操作系统课程设计–阅读xv6源码"></a>操作系统课程设计–阅读xv6源码</h2><p>操作系统课设作业——_跟MIT 6.S081课程读源码，写报告。</p>
<h3 id="一、内存管理模型"><a href="#一、内存管理模型" class="headerlink" title="一、内存管理模型"></a>一、内存管理模型</h3><p>在<code>main.c</code>中，有<code>kinit() kvminit()</code>来初始化页表分配器，创建内核的页表。<code>exec</code>是一个创建进程地址空间的重要系统调用函数。</p>
<h4 id="1-void-kinit-kernel-kallo-c"><a href="#1-void-kinit-kernel-kallo-c" class="headerlink" title="1. void kinit() (kernel/kallo.c)"></a>1. <code>void kinit()</code> (kernel/kallo.c)</h4><p><code>kinit()</code>函数设置页表分配器（page allocator）,也就是空闲页链表。源码中定义了一个名为kmem的结构体，里面封装了一个自旋锁和一个空闲页链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kinit</span><span class="params">()</span><span class="comment">//初始化分配器（空闲页链表）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);<span class="comment">//初始化锁</span></span><br><span class="line">freerange(end, (<span class="keyword">void</span>*)PHYSTOP);<span class="comment">//添加物理内存到空闲页链表，从end到PHYSTOP，直接映射，虚拟地址即物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤如下：</p>
<ul>
<li>初始化自旋锁（kmem的锁），其中locked值置为0，表示可获得</li>
<li>调用<code>freerange</code>，总的来说，<code>freerange</code>的作用是：在从end（内核后的第一个地址）到PHYSTOP这段地址上，添加内存到空闲页链表（刚开始链表是空的）。具体来说，<ul>
<li><code>freerange</code>对于这段空间的每一页调用<code>kfree</code><ul>
<li><code>kfree</code>对这一页物理地址的每个字节都置为1，然后设一个指向这段物理内存的指针，经过类型转换插到空闲页链表的头部</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-void-kvminit-void-kernel-vm-c"><a href="#2-void-kvminit-void-kernel-vm-c" class="headerlink" title="2.void kvminit(void) (kernel/vm.c)"></a>2.<code>void kvminit(void)</code> (kernel/vm.c)</h4><p><code>kvminit</code>函数创建内核的页表，设置好内核的地址空间，它的函数体内只有一个语句：调用<code>kvmmake</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kvminit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">  <span class="comment">//多次调用kvmmap建立PTE，映射各硬件资源、各进程内核栈等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvmmake</code> (kernel/vm.c)函数的步骤如下：</p>
<ul>
<li><p>调用<code>kalloc</code>从空闲页链表中取出头一个空闲页，用来存放根页表页</p>
</li>
<li><p>把该页内容全部置为0</p>
</li>
<li><p>多次调用<code>kvmmap</code>将内核所需要的硬件资源映射到物理地址，包括内核的指令和数据，KERNBASE 到 PHYSTOP（0x86400000）的物理内存，具体来说，有UART0，VIRTIO0，PLIC，kernel text，kernel data，trampoline，其中trampoline是映射到高位（被映射在虚拟地址空间的顶端），其他是直接映射，即虚拟地址和物理地址相同，如下图所示：</p>
</li>
</ul>
<p><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210826101819268.png" alt="image-20210826101819268"></p>
<ul>
<li><p><code>kvmmap</code>中调用<code>mappages</code>，新建PTE，映射实际上就是创建PTE的过程</p>
</li>
<li><p>调用<code>proc_mapstacks</code>为每个进程的内核栈分配一页，都是从空闲页链表中取页（不是直接映射），然后调用<code>kvmmap</code>映射</p>
</li>
</ul>
<h4 id="3-uint64-uvmalloc-pagetable-t-pagetable-uint64-oldsz-uint64-newsz-kernel-vm-c"><a href="#3-uint64-uvmalloc-pagetable-t-pagetable-uint64-oldsz-uint64-newsz-kernel-vm-c" class="headerlink" title="3. uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) (kernel/vm.c)"></a>3. <code>uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)</code> (kernel/vm.c)</h4><p><code>uvmalloc</code>函数的作用是为newsz比oldsz多出的部分分配内存，exec中用<code>uvmalloc</code>为每一个 ELF 段分配内存，步骤如下</p>
<ul>
<li>检测newsz是否比oldsz大，如果不是，则不需要新分配内存，直接返回原来的大小</li>
<li>对于多出来的大小，按页大小循环，对于每一页，调用<code>kalloc</code>取出一个空闲页，将该页内容都置为0，再调用<code>mappages</code>创建一条PTE，创建从虚拟地址到该空闲页物理地址的映射。如果失败，把刚拿出来的页再放回去</li>
</ul>
<h4 id="4-int-exec-char-path-char-argv-kernel-exec-c"><a href="#4-int-exec-char-path-char-argv-kernel-exec-c" class="headerlink" title="4. int exec(char *path, char **argv) (kernel/exec.c)"></a>4. <code>int exec(char *path, char **argv)</code> (kernel/exec.c)</h4><p>exec是一种系统调用，用于创建进程地址空间，加载并执行一个文件，将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。</p>
<p><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210826230553118.png" alt="image-20210826230553118"></p>
<p>它是创建用户地址空间的系统调用。它读取储存在文件系统上的文件用来初始化用户地址空间，用一个新的程序替换当前进程的内存和寄存器。</p>
<p>它的两个参数是：可执行文件的文件名，一个字符串参数数组。</p>
<p>当我们在执行<code>exec</code>系统调用的时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的内存镜像。内存镜像里面包括了程序对应的指令，全局的数据。应用程序可以逐渐扩展自己的内存，但是应用程序并没有直接访问物理内存的权限，例如应用程序不能直接访问物理内存的1000-2000这段地址。不能直接访问的原因是，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。<code>exec</code>表明了应用程序不能直接访问物理内存。新内存映像从文件系统中的文件中进行读取。这个文件必须有特定的格式，它指定了文件中哪部分存放指令，哪部分是数据，在哪条指令开始，等等。</p>
<p>当<code>exec</code> 成功时，它并不返回到调用程序，因为exec会完全替换当前进程的内存；相反，从文件中加载的指令在 ELF 头声明的入口点开始执行。另外，它保留文件描述符。</p>
<p><code>fork</code> 与<code>exec</code> 经常一起调用：<code>fork</code>创建一个和父进程相同的子进程，<code>exec</code> 去完全替换子进程为需要的进程。但是它们不能合并为一个函数，因为在这两个调用之间，shell 有机会重定向子进程的 I/O，而不干扰父进程的 I/O 设置。</p>
<p>函数实现过程如下：</p>
<ul>
<li>首先，调用<code>begin_op()</code>，表示要开始文件系统的调用。</li>
<li>使用 <code>namei(path)</code> 按路径打开 一个ELF 二进制文件（<em>xv6 应用程序用 ELF 格式来描述可执行文件），该函数返回一个inode（Xv6中的文件(包括目录)全部用inode数据结构表示，所有文件的inode都会被存储在磁盘上</em>），记为ip，并给ip上锁</li>
<li>然后，检查文件是否包含一个 ELF 二进制文件。检查的方法是调用<code>readi</code>读取 ELF 头（<em>一个 ELF 二进制文件包括一个 ELF 头(数据类型为(elfhdr)，和程序段头(proghdr)序列，虽然但是，xv6 程序只有一个程序段头，其他系统可能挺多的，分数据和指令</em>）。如果 ELF 头有正确的“魔法数字”，exec 就会认为该二进制文件是正确的类型</li>
<li><code>proc_pagetable</code>为进程分配一个没有使用的页表(不含user memory，含trampoline pages)，该函数中：<ul>
<li>调用<code>uvmcreate</code>申请一个空的用户页表<ul>
<li><code>uvmcreate</code>中，调用<code>kalloc</code>从空闲页链表中取出头一个空闲页，并把内容全部置为0</li>
</ul>
</li>
<li>调用<code>mappages</code>将 trampoline 和 trapframe 映射到高位地址空间</li>
</ul>
</li>
<li>按照程序段，循环地一段一段地把程序放入内存，其中包含了许多边界检测。将每一段放入内存分为以下几个步骤：<ul>
<li>调用<code>readi</code>读取这一段的内容</li>
<li>调用<code>uvmalloc</code>为这一段分配内存（设置好了虚拟、物理地址的映射关系，填好了页表）</li>
<li>调用<code>loadseg</code>加载这一段到内存中(用的是进程的页表，不是内核的页表)。在这个函数中，先用 <code>walkaddr</code> 传入虚拟地址va，返回物理地址pa，再用<code>readi</code>从ip所在地址读取该页的内容，读到pa中，这里，pa是一个核地址</li>
</ul>
</li>
<li>解锁并put ip</li>
<li>调用<code>end_op()</code>，表示结束文件系统的调用。</li>
<li>调用<code>uvmalloc</code>分配两页，一页是stack，一页是guard page，用<code>uvmclear</code>设置guard page为无效的、不可访问的保护页，用于检测栈溢出</li>
<li>调用<code>copyout</code>，从内核复制到用户，把argv参数数组复制到用户栈中来</li>
<li>调用<code>copyout</code>，把argv数组指针复制到栈中来</li>
<li>保存程序名（从路径中取斜杠后的字符连接而成），为debug做准备</li>
<li>更新当前进程的页表、大小等，释放旧的页表和它的物理内存</li>
<li>返回argc，它是<code>main(argc, argv)</code>里的参数</li>
</ul>
<h3 id="二、异常，中断调用流程，系统调用过程-syscall"><a href="#二、异常，中断调用流程，系统调用过程-syscall" class="headerlink" title="二、异常，中断调用流程，系统调用过程(syscall)"></a>二、异常，中断调用流程，系统调用过程(syscall)</h3><h4 id="1-trap名词解释"><a href="#1-trap名词解释" class="headerlink" title="1. trap名词解释"></a>1. trap名词解释</h4><p><code>trap</code>作为当发生以下三种情况的通用术语：</p>
<ul>
<li><p>系统调用，即用户程序执行 <code>ecall </code>指令要求内核为其做某事时</p>
</li>
<li><p>异常：一条指令（用户或内核）做了一些非法的事情，如除以零或使用无效的虚拟地址。</p>
</li>
<li><p>第三种情况是设备中断，当一个设备发出需要注意的信号时，例如当磁盘硬件完成一个读写请求时。</p>
</li>
</ul>
<h4 id="2-处理trap的过程介绍"><a href="#2-处理trap的过程介绍" class="headerlink" title="2. 处理trap的过程介绍"></a>2. 处理<code>trap</code>的过程介绍</h4><p>处理<code>trap</code>通常顺序是：</p>
<ul>
<li>trap 迫使控制权转移到内核</li>
<li>内核保存寄存器和其他状态，以便恢复执行</li>
<li>内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）</li>
<li>内核恢复保存的状态，并从 trap 中返回，代码从原来的地方恢复。</li>
</ul>
<p>在<code>trap</code>过程中，有一些非常重要的寄存器，比如</p>
<ul>
<li><p>STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中处理trap的指令的起始地址。</p>
</li>
<li><p>SEPC（Supervisor Exception Program Counter）寄存器，在trap的过程中保存程序计数器的值。</p>
</li>
<li><p>SSRATCH（Supervisor Scratch Register）寄存器，在内核进入用户空间前，放一个指向trampframe的指针</p>
</li>
</ul>
<p>总的来说，Xv6 trap 处理分为四个阶段：</p>
<ul>
<li>RISC-V CPU 采取的硬件行为（RISC-V CPU中都有一组控制寄存器，内核写入这些寄存器来告诉CPU 如何处理 trap）</li>
<li>为内核 C 代码准备的汇编入口</li>
<li>处理 trap 的 C 处理程序</li>
<li>以及系统调用或设备驱动服务。</li>
</ul>
<p>详细地来说，在用户mode切换到内核mode的过程中（也就是第二阶段到第三阶段），有以下步骤：</p>
<ul>
<li><p>内核trap处理代码的第一条指令是：进入trampoline（从ecall），而ecall并不会切换页表，所以最早真正处理trap的指令出现在用户页表中，提供了trap开始执行的位置，它通过stvec寄存器（保存trampoline的开端）</p>
<p>虽然用户地址空间中有trampoline和trapframe，但是用户不能读写，所以ecall所做的事情是：改变mode至内核mode；将pc存进sepc；跳转到stvec指向的指令</p>
<p>之后的切换页表、栈指针指向内核栈以运行需要栈的C代码、跳转到内核中C代码的某个合理位置等等，ecall不会去做，都留给内核软件来做，因为这是RISC，需要尽可能给软件提供大的灵活性。</p>
</li>
<li><p>在trampoline中，首先，我们需要保存32个用户寄存器。因为我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。</p>
</li>
<li><p>保存程序计数器PC，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序。</p>
</li>
<li><p>需要将mode改成supervisor mode，因为要使用内核中的各种各样的特权指令。</p>
</li>
<li><p>SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。所以在运行内核代码之前，我们需要将SATP指向kernel page table。</p>
</li>
<li><p>我们需要将堆栈寄存器指向位于内核的一个地址，因为我们需要一个堆栈来调用内核的C函数。</p>
</li>
<li><p>跳入内核的C代码。</p>
</li>
</ul>
<h4 id="3-核心函数介绍"><a href="#3-核心函数介绍" class="headerlink" title="3.  核心函数介绍"></a>3.  核心函数介绍</h4><p>接下来，就进入到内核空间，trap代码的执行流程如下：来自用户空间的 trap的处理路  <code>uservec</code>(kernel/trampoline.S) ， 然 后 是 <code>usertrap</code>(kernel/trap.c) ； 返 回 时 是<code>usertrapret</code>(kernel/trap.c)，然后是 <code>userret</code>(kernel/trampoline.S)</p>
<h5 id="3-1-uservec"><a href="#3-1-uservec" class="headerlink" title="3.1 uservec"></a>3.1 <code>uservec</code></h5><p>这是一个由汇编语言写的函数，<code>uservec</code>启动时，所有 32 个寄存器都包含被中断的代码所拥有的值。这时<code>uservec</code>需要能够修改一些寄存器，以便设置 satp 和生成保存寄存器的地址。</p>
<ul>
<li><code>csrrw </code>指令将 a0 和 sscratch 的内容互换，<code>uservec</code>便有了一个寄存器（<code>a0</code>）可以使用。此时<code>a0</code> 将指向当前进程的 trapframe</li>
<li>在trapframe保存所有的用户寄存器，包括a0</li>
<li>将trapframe中的当前进程的内核栈指针、hartid（当前运行的核的编号）、<code>usertrap</code>地址存入寄存器sp、tp、t0</li>
<li>交换用户页表和内核页表，即satp切换至内核页表</li>
<li>跳至<code>usertrap()</code>函数，它是是要执行的第一个C函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">csrrw a0, sscratch, a0 #csrrw 指令将 a0 和 sscratch的内容互换，uservec便有了一个寄存器（a0）可以使用，此时a0将指向当前进程的trapframe</span><br><span class="line">     #用多条sd指令在trapframe保存所有的用户寄存器</span><br><span class="line">     sd ra, 40(a0)</span><br><span class="line">     sd sp, 48(a0)</span><br><span class="line">     sd gp, 56(a0)</span><br><span class="line">     ......</span><br><span class="line">     csrr t0, sscratch #将t0(a0)也存入trapframe。</span><br><span class="line">     sd t0, 112(a0)</span><br><span class="line">     ld sp, 8(a0)#将(trapframe中的)内核栈指针存进寄存器sp</span><br><span class="line">     ld tp, 32(a0)#将(trapframe中的)hartid存进寄存器tp</span><br><span class="line">     ld t0, 16(a0)#将(trapframe中的)usertrap()的地址存进寄存器t0</span><br><span class="line">     ld t1, 0(a0)</span><br><span class="line">     csrw satp, t1 #交换用户页表和内核页表</span><br><span class="line">     jr t0 #跳至t0，即usertrap</span><br></pre></td></tr></table></figure>



<h5 id="3-2-usertrap"><a href="#3-2-usertrap" class="headerlink" title="3.2 usertrap"></a>3.2 <code>usertrap</code></h5><p>从trampoline.s中的uservec汇编函数跳转而来，作用是改变 stvec，这样在内核中发生的 trap 将由 <code>kernelvec </code>处理，确定 trap 的原因，处理它，然后返回</p>
<ul>
<li><p>改变 stvec，这样在内核中发生的 trap 将由 kernelvec 处理</p>
</li>
<li><p>保存 sepc(用户 PC)</p>
</li>
<li><p>如果是系统调用，(8表示系统调用)，启用中断<code>intr_on()</code>，调用<code>syscall()</code>去执行该系统调用，<code>syscall()</code>内容如下：</p>
<ul>
<li><p>从 trapframe 中的 a7 中得到系统调用号，保存到num</p>
</li>
<li><p>将系统调用号作为索引在syscalls数组中查找相应函数,将其返回值记录在p-&gt;trapframe-&gt;a0中，返回值负数表示错误，0 或正数表示成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) p-&gt;trapframe-&gt;a0 = syscalls[num](); <span class="comment">// 在syscalls数组中寻找系统调用号为num的函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果系统调用号无效，syscall 会打印错误并返回-1。</p>
</li>
</ul>
</li>
<li><p>如果是设备中断，调用<code>devintr</code>去处理</p>
</li>
<li><p>否则，是异常，内核会杀死故障进程</p>
</li>
<li><p>如果该线程需要让出CPU，则调用<code>yield()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>)yield();<span class="comment">//线程切换函数，让出CPU</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用 <code>usertrapret</code>，去回到用户空间</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  w_stvec((uint64)kernelvec);<span class="comment">//改变 stvec，这样在内核中发生的 trap 将由 kernelvec 处理</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();<span class="comment">//保存 sepc(用户 PC)</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;<span class="comment">//如果是系统调用，8表示系统调用</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;<span class="comment">//  pc+4，使sepc指向下一条指令</span></span><br><span class="line">    intr_on(); <span class="comment">//启用中断</span></span><br><span class="line">    syscall();<span class="comment">//去执行该系统调用（在一个表单中，根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数）</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;<span class="comment">//如果是设备中断，调用devintr去处理</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则,是异常，内核会杀死故障进程</span></span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)<span class="comment">//检查进程是否已经被杀死</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="comment">//检查进程是否应该让出 CPU</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();<span class="comment">//线程切换函数，让出CPU</span></span><br><span class="line">  usertrapret();<span class="comment">//调用 usertrapret，回到用户空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-3-usertrapret"><a href="#3-3-usertrapret" class="headerlink" title="3.3 usertrapret"></a>3.3 <code>usertrapret</code></h5><p><code>usertrapret</code>函数设置 RISC-V 控制寄存器，为以后的用户空间 trap 做准备</p>
<ul>
<li><p>调用<code>intr_off()</code>停止中断，因为要修改stvec</p>
</li>
<li><p>写stvec，改变 stvec 来引用 uservec，指向user trap handler，而不是kernel trap handle，这意味着，尽管我们此时在内核中，但如果发生中断，执行的是用户trap handler</p>
</li>
<li><p>设置trapframe中的某些值，以便下次trap用（准备 uservec 所依赖的 trapframe 字段），包括内核页表、进程的内核栈、usertrap函数地址、cpu核编号</p>
</li>
<li><p>设置符号位，使得下次执行sret的时候，我们想要返回user mode而不是supervisor mode；在执行完sret之后，打开中断</p>
</li>
<li><p>将 sepc 设置为先前保存的用户程序计数器PC(trampoline.s中的sret指令曾将pc设置成SEPC寄存器的值，现在再设回来)</p>
</li>
<li><p>页表位置存入satp（根据user page table地址生成相应的SATP值）,以便在<code>trampoline.s</code>中完成page table的切换(c语言代码中切换不了，而只有trampoline中代码是同时在用户和内核空间中映射)</p>
</li>
<li><p>调用 userret，因为 userret 中的汇编代码会切换页表。sret打开中断</p>
</li>
<li><p>计算出我们将要跳转到汇编代码的地址:tampoline中的userret函数</p>
</li>
<li><p>将fn指针作为一个函数指针，执行<code>userret</code>函数,并传入两个参数，两个参数存储在a0，a1寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usertrapret</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  intr_off();<span class="comment">//停止中断，因为要修改stvec</span></span><br><span class="line">  w_stvec(TRAMPOLINE + (uservec - trampoline));<span class="comment">//写stvec，改变 stvec 来引用 uservec，指向user trap handler，而不是kernel trap handler,AA这意味着，尽管我们此时在内核中，但如果发生中断，执行的是用户trap handler</span></span><br><span class="line">  <span class="comment">//设置trapframe中的某些值，以便下次trap用（准备 uservec 所依赖的 trapframe 字段）</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();<span class="comment">//内核页表</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">//进程的内核栈</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;<span class="comment">//usertrap函数地址</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();<span class="comment">//cpu核编号</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">//下次执行sret的时候，我们想要返回user mode而不是supervisor mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">//在执行完sret之后，是否打开中断：打开</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line">  <span class="comment">//将 sepc 设置为先前保存的用户程序计数器PC(trampoline.s中的sret指令曾将pc设置成SEPC寄存器的值，现在再设回来)</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line">  <span class="comment">//页表位置存入satp（根据user page table地址生成相应的SATP值）,以便在trampoline.s中完成page table的切换(c语言代码中切换不了，而只有trampoline中代码是同时在用户和内核空间中映射)</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line">  <span class="comment">//调用 userret，因为 userret 中的汇编代码会切换页表。sret打开中断</span></span><br><span class="line">  uint64 fn = TRAMPOLINE + (userret - trampoline);<span class="comment">//计算出我们将要跳转到汇编代码的地址:tampoline中的userret函数</span></span><br><span class="line">  ((<span class="keyword">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);<span class="comment">//将fn指针作为一个函数指针，执行userret函数,并传入两个参数，两个参数存储在a0，a1寄存器中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-4-userret"><a href="#3-4-userret" class="headerlink" title="3.4 userret"></a>3.4 <code>userret</code></h5><p>现在，页表还是指向kernel page table，这条指令的作用是将其指向user page table</p>
<ul>
<li>切换页表，清空页表缓存</li>
<li>找到a0寄存器的地址，存到t0</li>
<li>在uservec中交换过SSRATCH和a0寄存器，现在交换回来</li>
<li>现在所有的寄存器内容还是属于内核，现在都换成用户寄存器，除了a0，（a0仍然是指向trapframe的指针）</li>
<li>交换SSCRATCH寄存器和a0寄存器的值，交换后，a0持有的是系统调用的返回值，SSCRATCH持有的是trapframe的地址</li>
<li>最后，执行sret，这是在kernel中的最后一条指令了</li>
<li>执行完它，程序会切换回user mode，SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器），并且重新打开中断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">csrw satp, a1 # 切换页表</span><br><span class="line">sfence.vma zero, zero # 清空页表缓存</span><br><span class="line">ld t0, 112(a0) #找到a0寄存器的地址，存到t0</span><br><span class="line">csrw sscratch, t0 #在uservec中交换过SSRATCH和a0寄存器，现在交换回来</span><br><span class="line"># 现在所有的寄存器内容还是属于内核，现在都换成用户寄存器，除了a0，（a0仍然是指向trapframe的指针）</span><br><span class="line">ld ra, 40(a0)</span><br><span class="line">ld sp, 48(a0)</span><br><span class="line">...</span><br><span class="line"># 交换SSCRATCH寄存器和a0寄存器的值</span><br><span class="line">csrrw a0, sscratch, a0</span><br><span class="line"># 现在，a0持有的是系统调用的返回值，SSCRATCH持有的是trapframe的地址</span><br><span class="line"># 最后，执行sret，这是在kernel中的最后一条指令了</span><br><span class="line">sret</span><br><span class="line"># 执行完它，程序会切换回user mode，SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器），并且重新打开中断</span><br></pre></td></tr></table></figure>



<h4 id="4-系统调用实例"><a href="#4-系统调用实例" class="headerlink" title="4. 系统调用实例"></a>4. 系统调用实例</h4><p>下面举例说明用户调用是如何在内核中实现 exec 系统调用的。</p>
<ul>
<li>用户代码(user/initcode.S)将 <code>exec</code> 的参数放在寄存器 a0和 a1 中，并将系统调用号放在 a7 中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">la a0, init</span><br><span class="line">la a1, argv</span><br><span class="line">li a7, SYS_exec</span><br><span class="line">ecall</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该系统调用号与函数指针表 syscalls 数组(kernel/syscall.c)中的项匹配</p>
</li>
<li><p>ecall 指令进入内核，执行<code>uservec</code>、<code>usertrap</code>，然后执行 <code>syscall</code>。</p>
</li>
<li><p><code>syscall</code> (kernel/syscall.c)从 trapframe 中的 a7 中得到系统调用号，并其作为索引在syscalls 查找相应函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;<span class="comment">//从 trapframe 中的 a7 中得到系统调用号</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();<span class="comment">//作为索引在syscalls 查找相应函数,将其返回值记录在p-&gt;trapframe-&gt;a0中，返回值负数表示错误，0 或正数表示成功。</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果系统调用号无效，syscall 会打印错误并返回-1。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于<code>exec</code>，a7 是为<code> SYS_exec</code>，这会让 <code>syscall</code> 调用 <code>exec</code> 的实现函数<code> sys_exec</code>。在<code> sys_exec</code>中，调用了第一章中提到的exec函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_exec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> path[MAXPATH], *argv[MAXARG];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  uint64 uargv, uarg;</span><br><span class="line">  <span class="built_in">memset</span>(argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(argv));</span><br><span class="line">  ...<span class="comment">//边界检测</span></span><br><span class="line">  <span class="keyword">int</span> ret = exec(path, argv);<span class="comment">//调用exec.c中的函数exec</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NELEM(argv) &amp;&amp; argv[i] != <span class="number">0</span>; i++)</span><br><span class="line">    kfree(argv[i]);<span class="comment">//释放参数数组</span></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>当系统调用函数返回时，<code>syscall</code> 将其返回值记录在 p-&gt;trapframe-&gt;a0 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();<span class="comment">//记录syscall的返回值</span></span><br></pre></td></tr></table></figure></li>
<li><p>用户空间的 exec()将会返回该值，因为 RISC-V 上的 C 调用通常将返回值放在 a0 中。系统调用返回负数表示错误，0 或正数表示成功。如果系统调用号无效，<code>syscall </code>会打印错误并返回 1。</p>
</li>
</ul>
<h3 id="三、自旋锁的运作-gt-真正理解死锁原理"><a href="#三、自旋锁的运作-gt-真正理解死锁原理" class="headerlink" title="三、自旋锁的运作-&gt;真正理解死锁原理"></a>三、自旋锁的运作-&gt;真正理解死锁原理</h3><h4 id="1-锁的概念"><a href="#1-锁的概念" class="headerlink" title="1. 锁的概念"></a>1. 锁的概念</h4><p>为什么需要锁？我们想要使用多个CPU核，如果一个应用程序运行在多个CPU核上，并且执行了系统调用，那么内核需要能够处理并行的系统调用。如果系统调用并行的运行在多个CPU核上，那么它们可能会并行的访问内核中共享的数据结构(如proc,buffer cache)。当并行的访问数据结构时，例如一个核在读取数据，另一个核在写入数据，我们需要使用锁来协调对于共享数据的更新，以确保数据的一致性。XV6的操作系统会有多把锁，这样就能获得某种程度的并发执行。如果两个系统调用使用了两把不同的锁，那么它们就能完全的并行运行。在一些其他场合也需要锁，例如对于printf，如果我们将一个字符串传递给它，XV6会尝试原子性的将整个字符串输出，而不是与其他进程的printf交织输出。</p>
<p>xv6中，有两种类型的锁：自旋锁和睡眠锁，我们只讨论自旋锁。</p>
<h4 id="2-锁的其他问题"><a href="#2-锁的其他问题" class="headerlink" title="2. 锁的其他问题"></a>2. 锁的其他问题</h4><p>直接为每个对象自动分配一个锁会带来错误的结果:现在我们有两个目录对象，一个是d1，另一个是d2，我们要将d1下的一个文件移动到d2，那么我们会先对d1加锁，删除x，之后再释放对于d1的锁；之后我们会对d2加锁，增加y，之后再释放d2的锁。在我们完成了第一步，也就是删除了d1下的x文件，但是还没有执行第二步，也就是创建d2下的y文件时。其他的进程会看到什么样的结果是：其他的进程会看到文件完全不存在。这明显是个错误的结果，因为文件还存在只是被重命名了，文件在任何一个时间点都是应该存在的。但是如果我们按照上面的方式实现锁的话，那么在某个时间点，文件看起来就是不存在的。</p>
<p>所以这里正确的解决方法是，我们在重命名的一开始就对d1和d2加锁，之后删除x再添加y，最后再释放对于d1和d2的锁。 </p>
<p>锁可能带来的一个重要缺点是：死锁。解决方案是，如果你有多个锁，你需要对锁进行排序，所有的操作都必须以相同的顺序获取锁。但是不幸的是，具体实现中，不同模块内部的锁需要相互泄露，这样才能完成全局锁排序。</p>
<h4 id="3-自旋锁的实现："><a href="#3-自旋锁的实现：" class="headerlink" title="3. 自旋锁的实现："></a>3. 自旋锁的实现：</h4><p>锁的特性是：只有一个进程可以获取锁，其他程序会一直spin，这就是它叫做自旋锁(spin lock)原因。</p>
<p>自旋锁的实现依赖于一个特殊的硬件指令，这个特殊的硬件指令会保证一次test-and-set操作的原子性。在RISC-V上，这个特殊的指令是<code>amoswap</code>（atomic memory swap）。这个指令接收3个参数，分别是address，寄存器r1，寄存器r2。这条指令会先锁定住address，将address中的数据保存在一个临时变量中（tmp），之后将r1中的数据写入到地址中，之后再将保存在临时变量中的数据写入到r2中，最后再对于地址解锁。</p>
<p>自旋锁需要处理两类并发:</p>
<ul>
<li>一类是不同CPU之间的并发</li>
<li>一类是相同CPU上中断和普通程序之间的并发。针对后一种情况，我们需要在acquire中关闭中断。中断会在release的结束位置再次打开，因为在这个位置才能再次安全的接收中断。</li>
</ul>
<p>值得注意的是，当一个 CPU 获取任何锁时，xv6 总是禁用该 CPU 上的中断。中断仍然可能发生在其他 CPU 上</p>
<p>自旋锁(spinlock)的结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// 当锁可获得时为0，被持有时为1</span></span><br><span class="line">  <span class="keyword">char</span> *name;        <span class="comment">// 锁的名字</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// 持有锁的cpu</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要有两个与它密切相关的函数：acquire获取锁和release释放锁</p>
<ul>
<li><p><code>acquire(struct spinlock *lk)</code>函数，获取锁</p>
<ul>
<li><p>执行push_off()函数，其中调用intr_off来禁止中断</p>
</li>
<li><p>调用可移植的c语言标准库里的函数<code>__sync_lock_test_and_set</code>来进行test-and-set循环，它本质上为 amoswap 指令（是一条原子性的指令）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"><span class="comment">//每次循环将1与locked值交换</span></span><br><span class="line"><span class="comment">//如果交换得到的值是1，证明该锁已经被持有，则继续循环等待，而因为交换的是1，locked值也保持不变</span></span><br><span class="line"><span class="comment">//如果交换得到的值是0，证明该锁可获得，则停止循环，此时locked值变为了1，表示该锁被占用了</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用<code>__sync_synchronize()</code>作为内存屏障，实际作用是：必须在锁获取以后才能进入临界区</p>
</li>
<li><p>记录获取该锁的 CPU (只有在持有锁的时候才能改变。)</p>
</li>
</ul>
</li>
<li><p><code>release(struct spinlock *lk)</code>函数</p>
<ul>
<li><p>清除 lk-&gt;cpu 字段</p>
</li>
<li><p>调用<code>__sync_synchronize()</code>作为内存屏障，实际作用：必须在锁释放之前使用临界区</p>
</li>
<li><p>调用<code>__sync_lock_release</code>（c语言库函数）释放锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"><span class="comment">//释放锁，只需将locked值赋为0即可，但是赋值对于并发代码来说可能是非原子性的，因为C标准允许编译器用多条存储指令来实现赋值</span></span><br><span class="line"><span class="comment">//所以 使用__sync_lock_release，这也是一个c语言库函数，具有原子性</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用<code> pop_off()</code>来跟踪当前 CPU 上锁的嵌套级别,当该计数达到零时，pop_off 会恢复最外层临界区开始时的中断启用状态。其中调用<code>intr_on()</code>来启用中断</p>
</li>
</ul>
</li>
</ul>
<p>首先线程会运行在所有可用的CPU核上，其次每个CPU核会在多个线程之间切换。</p>
<ul>
<li>对于每个用户进程都有一个内核线程来执行来自用户进程的系统调用。所有的内核线程都共享了内核内存，所以XV6的内核线程的确会共享内存。</li>
<li>每个用户进程都有一个控制线程来执行该进程的用户指令，有独立的内存地址空间，你可以有多个用户进程，但是每个用户进程都是拥有一个线程的独立地址空间。XV6中的进程不会共享内存。</li>
</ul>
<h3 id="四、线程切换-swtch函数"><a href="#四、线程切换-swtch函数" class="headerlink" title="四、线程切换-swtch函数"></a>四、线程切换-swtch函数</h3><h4 id="1-xv6中的进程与线程"><a href="#1-xv6中的进程与线程" class="headerlink" title="1. xv6中的进程与线程"></a>1. xv6中的进程与线程</h4><p>xv6中的线程、进程定义与我们熟知的有一些区别，xv6中，每个进程只有一个线程，要么是用户空间线程，要么是内核空间线程，当用户程序在运行时，实际上是用户进程中的一个用户线程在运行。如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的用户空间状态会被保存在程序的trapframe中，同时属于这个用户程序的内核线程被激活。</p>
<p>每个CPU核在一个时间只会运行一个线程，它要么是运行用户进程的线程，要么是运行内核线程，要么是运行这个CPU核对应的调度器线程。</p>
<p>因此，如果XV6内核决定从一个用户进程切换到另一个用户进程，那么首先在内核中第一个进程的内核线程会被切换到第二个进程的内核线程。之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回也是通过恢复trapframe中保存的用户进程状态完成。</p>
<p>总的来说：定时器中断，将控制权交给内核，内核自愿让出CPU（抢占式调度pre-emptive)</p>
<p>进程共有3个状态：RUNNING, RUNNABLE, SLEEPING, (UNUSED)</p>
<ul>
<li>对于RUNNING的进程，CPU中保存它的PC</li>
<li>对于RUNNABLE的进程，要保存它运行时的所有CPU状态（PC和CPU寄存器）</li>
</ul>
<h4 id="2-线程切换的过程"><a href="#2-线程切换的过程" class="headerlink" title="2. 线程切换的过程"></a>2. 线程切换的过程</h4><ul>
<li>从一个用户进程切换到另一个用户进程，（也许时因为定时器中断），都需要从第一个用户进程接入到内核中，保存用户进程的状态，trampoline代码将用户寄存器保存于用户进程对应的trapframe对象中，并运行第一个用户进程的内核线程。</li>
<li>在内核中运行usertrap，来实际执行相应的中断处理程序。这时，CPU正在进程P1的内核线程和内核栈上，执行内核中普通的C代码；</li>
<li>内核线程决定它想出让CPU，调用swtch（意为switch，关键字冲突），保存用户进程P1对应内核线程的寄存器至context对象，返回调度器函数，做一些清理，使原进程进入RUNNABLE状态，找到一个RUNNABLE的进程，再调用swtch，保存自己的寄存器至context，切换至新进程的内核线程。</li>
<li>之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器（在trapframe中）。</li>
<li>最后返回到第二个用户进程继续执行，进入用户空间。</li>
</ul>
<p>过程示意图如下所示：</p>
<p><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210826011841027.png" alt="image-20210826011841027"><br>XV6会确保返回到用户空间时，中断是打开的。这意味着当代码在用户空间执行时，定时器中断总是能发生。在内核中会更加复杂点，因为内核中偶尔会关闭中断，比如当获取锁的时候，中断会被关闭，只有当锁被释放之后中断才会重新打开。</p>
<h4 id="3-swtch函数"><a href="#3-swtch函数" class="headerlink" title="3.swtch函数"></a>3.<code>swtch</code>函数</h4><p>函数 <code>swtch</code> 执行内核线程切换的保存和恢复，（意为switch，为避免关键字冲突而命名） <code>swtch</code>并不直接知道线程，它只是保存和恢复寄存器组，称为上下文(context)，保存在进程的结构体中p-&gt;context，在xv6中，内核线程只能与调度器线程切换</p>
<p><code>swtch</code>有两个参数：struct context *old 和 struct context *new。它将当前的寄存器保存在old 中，从 new 中加载寄存器，然后返回。</p>
<p>在中断结束时，其中一种情况是 <code>usertrap</code> 调用 <code>yield</code>，使cpu让出当前进程。<code>yield</code> 中调用 <code>sched</code>，在<code>sched</code>函数中调用了<code>swtch</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</span><br><span class="line"><span class="comment">//将当前的内核线程的寄存器保存到p-&gt;context中，然后不返回这里，继续执行当前CPU核的调度器线程。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>用多条sd指令将当前的某些寄存器保存在 old 中。swtch函数中只需要处理C编译器不会保存，但是对于swtch函数又有用的一些寄存器(Callee Saved Register)，而Caller Saved Register会被C编译器保存在当前的栈上，当函数返回时，这些寄存器会自动恢复</p>
</li>
<li><p>用多条ld指令把 new 中的寄存器恢复到cpu寄存器中</p>
</li>
<li><p>执行ret指令，返回到调度器线程中</p>
<p>其中，不保存 pc是因为不管怎样都会随着函数调用更新。而重要的是，<strong>swtch</strong> 保存了 ra 寄存器（ <strong>swtch</strong> 应该返回的地址，即调用点）</p>
<p>线程切换的过程中，处理器中的寄存器是唯一的不稳定状态，且需要保存并恢复。而所有其他在内存中的数据会保存在内存中不被改变，所以不用特意保存并恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将当前的某些寄存器保存在 old 中</span><br><span class="line">sd ra, 0(a0)</span><br><span class="line">sd sp, 8(a0)</span><br><span class="line">sd s0, 16(a0)</span><br><span class="line">...</span><br><span class="line"># 把 new 中的寄存器恢复到cpu寄存器中</span><br><span class="line">ld ra, 0(a1)</span><br><span class="line">ld sp, 8(a1)</span><br><span class="line">ld s0, 16(a1)</span><br><span class="line">...</span><br><span class="line">ret #返回</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="五、进程调度–调度器scheduler"><a href="#五、进程调度–调度器scheduler" class="headerlink" title="五、进程调度–调度器scheduler()"></a>五、进程调度–调度器scheduler()</h3><h4 id="1-调度器的概念"><a href="#1-调度器的概念" class="headerlink" title="1. 调度器的概念"></a>1. 调度器的概念</h4><p>每个CPU有一个完整的、单独的调度器线程，调度器的context存储在CPU结构体中</p>
<h4 id="2-调度器函数scheduler"><a href="#2-调度器函数scheduler" class="headerlink" title="2. 调度器函数scheduler() "></a>2. 调度器函数<code>scheduler() </code></h4><ul>
<li><p>将c-&gt;proc设置为0，将CPU核运行的进程对象设置为0，表明现在cpu没有运行进程</p>
</li>
<li><p>循环检查所有的进程并找到一个RUNNABLE的，把它的状态改为RUNNING，并且调用<code>swtch</code>来保存调度器线程的寄存器，并恢复该目标进程的寄存器，之后由<code>swtch</code>函数返回到目标进程的内核线程的sched函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"><span class="comment">//保存调度器线程的寄存器，并恢复目标进程的内核线程</span></span><br></pre></td></tr></table></figure>

<p>每次循环都要获取锁、释放锁，锁主要保证了以下两个动作的原子性：</p>
<ul>
<li>将进程的状态设置为RUNNING</li>
<li>将进程的context移到RISC-V的寄存器中</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  c-&gt;proc = <span class="number">0</span>; <span class="comment">// 将CPU核运行的进程对象设置为0：现在cpu没有运行进程</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    intr_on();<span class="comment">//开启中断</span></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<span class="comment">//检查所有的进程并找到一个来运行</span></span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;<span class="comment">//找一个RUNNABLE的进程</span></span><br><span class="line">        p-&gt;state = RUNNING;<span class="comment">//要切换至这个进程，把状态改为RUNNING</span></span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<span class="comment">//保存调度器线程的寄存器，并恢复目标进程的寄存器（实际上恢复的是目标进程的内核线程）</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);<span class="comment">//释放锁，然后别的cpu核可以看到该进程是RUNABLE状态，可以运行它了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="六、创建进程"><a href="#六、创建进程" class="headerlink" title="六、创建进程"></a>六、创建进程</h3><h4 id="1-创建进程的方法"><a href="#1-创建进程的方法" class="headerlink" title="1. 创建进程的方法"></a>1. 创建进程的方法</h4><p>创建进程的一个常用的写法是先调用fork，再在子进程中调用exec：fork创建一个和父进程一样的子进程，exec完全替换当前的子进程。这里实际上有些浪费，fork首先拷贝了整个父进程的，但是之后exec整个将这个拷贝丢弃了，并用要运行的文件替换了内存的内容，这里的拷贝操作浪费了。</p>
<p>然而，exec总是基于现有的进程去完全替换，<code>allocproc()</code>是完全创建一个新进程，fork函数中正是调用了<code>allocproc()</code>函数。</p>
<p>copy-on-write(COW) scheduler() 是一种优化策略，它只拷贝执行exec所需要的内存，然而xv6中并没有实现写时复制，而是作为lab实验让同学们做。</p>
<p>当一个新的进程第一次被调度时，它开始于<code>forkret</code>(kernel/proc.c)。<code>forkret </code>的存在是为了释放 p-&gt;lock，否则，新进程需要从 <code>usertrapret </code>开始执行。</p>
<h4 id="2-创建进程的函数allocproc"><a href="#2-创建进程的函数allocproc" class="headerlink" title="2. 创建进程的函数allocproc()"></a>2. 创建进程的函数<code>allocproc()</code></h4><p><code>allocproc</code>在创建每个进程时都会被调用，而<code>userinit </code>只在第一个进程创建时调用，<code>allocproc</code>实现如下：</p>
<ul>
<li><p>在进程数组中找到一个未使用(UNUSED)的进程</p>
</li>
<li><p>为该进程分配一个pid</p>
</li>
<li><p>调用<code>kalloc</code>分配一个 trapframe 页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//kalloc()从空闲页链表中取出头一个空闲页</span></span><br></pre></td></tr></table></figure></li>
<li><p>调用<code>proc_pagetable</code>创建一个页表</p>
</li>
<li><p>初始化进程的context，全部置为0</p>
</li>
<li><p>将ra寄存器置为forkret，设置sp寄存器</p>
<p>ra是一个重要寄存器，保存进程的第一个switch调用会返回的位置，到时候从swtch返回会跳到forkret的最开始位置</p>
</li>
<li><p>调用<code>usertrapret()</code>，这是一个假的函数，它会使得程序表现的看起来像是从trap中返回</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc* <span class="title">allocproc</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//创建一个进程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<span class="comment">//找到一个未使用的进程</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);<span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;</span><br><span class="line">  	p-&gt;pid = allocpid();<span class="comment">//分配一个pid</span></span><br><span class="line">  	p-&gt;state = USED;</span><br><span class="line">  	<span class="comment">// 分配一个 trapframe 页</span></span><br><span class="line">  	<span class="keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="number">0</span>)&#123;<span class="comment">//从空闲页链表中取出头一个空闲页</span></span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	p-&gt;pagetable = proc_pagetable(p);<span class="comment">//创建一个页表</span></span><br><span class="line">  	<span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));<span class="comment">//创建context</span></span><br><span class="line">  	p-&gt;context.ra = (uint64)forkret;<span class="comment">//调用forkret，释放调度器之前获取的锁。 ra是一个重要寄存器，保存进程的第一个switch调用会返回的位置</span></span><br><span class="line">  	p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br><span class="line">  	<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、心得体会"><a href="#七、心得体会" class="headerlink" title="七、心得体会"></a>七、心得体会</h3><ul>
<li>这一万余行的xv6操作系统虽小，却五脏俱全，学习源码的过程中，刚开始我一头雾水，我想追踪主要的代码块，大致了解下每个部分是如何连接起来的，但是发现几乎每一个函数都是层层嵌套的，我想搞清楚一个函数的内容，可能得递归地跳跃五六次去彻底读懂它，这样很容易忘记最初的函数是在做什么。经过一段时间时间的准备与摸索，我尝试根据6.S081的课程视频以及xv6 book来逐章学习，尽管如此，还是遇到了不少困难，比如课程的顺序并不是完全符合拓扑序的，我在阅读内存管理相关源码时，一直无法理解trampoline与trapframe的概念，等到后面学习trap时，才理解到它们的用处以及巧妙之处。先前也没有搞清楚内核页表，进程页表中的内核栈的含义，后来在学习线程相关知识后才明白，xv6中一个进程要么拥有一个内核空间线程、要么拥有一个用户空间线程，而所有的内核线程之间是共享内存的，这才理解了那两张图。对于exec的理解，也是在学习完进程切换才理解的。另外，xv6也是一个具有可扩展性的操作系统，我也尝试了解了lab，但我对阅读源码更有兴趣，也认为阅读源码能帮助我学习到更多。</li>
<li>为什么有些函数要用汇编来实现，而不是C语言？C语言中很难与寄存器交互。C语言不能更改sp、ra寄存器等。某些函数中的操作是在C语言的层级之下，所以不能使用C语言。</li>
<li>阅读了xv6的源码，我复习了在课堂中学习的知识，例如信号量、页表、虚拟内存等，xv6的源码非常简洁、美观，在几乎每个函数中都有对边界情况的检测，这也帮助我以后能写出更具鲁棒性的程序。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Pink Crow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/08/26/%E9%98%85%E8%AF%BBxv6%E6%BA%90%E7%A0%81/">http://example.com/2021/08/26/%E9%98%85%E8%AF%BBxv6%E6%BA%90%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828003805755.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/08/20/axios%E5%AE%9E%E7%8E%B012306%E7%81%AB%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD-%E7%88%AC%E8%99%AB/"><img class="next-cover" src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210827235254392.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">axios实现12306火车票查询功能 爬虫</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828114334929.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Pink Crow</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">平安喜乐 万事顺意</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E2%80%93%E9%98%85%E8%AF%BBxv6%E6%BA%90%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">操作系统课程设计–阅读xv6源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一、内存管理模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-void-kinit-kernel-kallo-c"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. void kinit() (kernel&#x2F;kallo.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-void-kvminit-void-kernel-vm-c"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.void kvminit(void) (kernel&#x2F;vm.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-uint64-uvmalloc-pagetable-t-pagetable-uint64-oldsz-uint64-newsz-kernel-vm-c"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) (kernel&#x2F;vm.c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-int-exec-char-path-char-argv-kernel-exec-c"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. int exec(char *path, char **argv) (kernel&#x2F;exec.c)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%AD%E6%96%AD%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B-syscall"><span class="toc-number">1.2.</span> <span class="toc-text">二、异常，中断调用流程，系统调用过程(syscall)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-trap%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. trap名词解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86trap%E7%9A%84%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 处理trap的过程介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.  核心函数介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-uservec"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">3.1 uservec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-usertrap"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">3.2 usertrap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-usertrapret"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3.3 usertrapret</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-userret"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">3.4 userret</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 系统调用实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E8%BF%90%E4%BD%9C-gt-%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3%E6%AD%BB%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">三、自旋锁的运作-&gt;真正理解死锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 锁的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%81%E7%9A%84%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 锁的其他问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 自旋锁的实现：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2-swtch%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">四、线程切换-swtch函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-xv6%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. xv6中的进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 线程切换的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-swtch%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.swtch函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E2%80%93%E8%B0%83%E5%BA%A6%E5%99%A8scheduler"><span class="toc-number">1.5.</span> <span class="toc-text">五、进程调度–调度器scheduler()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 调度器的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%87%BD%E6%95%B0scheduler"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 调度器函数scheduler() </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">六、创建进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 创建进程的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%87%BD%E6%95%B0allocproc"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 创建进程的函数allocproc()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">七、心得体会</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/08/26/%E9%98%85%E8%AF%BBxv6%E6%BA%90%E7%A0%81/" title="操作系统课程设计--阅读xv6源码"><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828003805755.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统课程设计--阅读xv6源码"/></a><div class="content"><a class="title" href="/2021/08/26/%E9%98%85%E8%AF%BBxv6%E6%BA%90%E7%A0%81/" title="操作系统课程设计--阅读xv6源码">操作系统课程设计--阅读xv6源码</a><time datetime="2021-08-26T08:13:05.000Z" title="发表于 2021-08-26 16:13:05">2021-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/20/axios%E5%AE%9E%E7%8E%B012306%E7%81%AB%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD-%E7%88%AC%E8%99%AB/" title="axios实现12306火车票查询功能 爬虫"><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210827235254392.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="axios实现12306火车票查询功能 爬虫"/></a><div class="content"><a class="title" href="/2021/08/20/axios%E5%AE%9E%E7%8E%B012306%E7%81%AB%E8%BD%A6%E7%A5%A8%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD-%E7%88%AC%E8%99%AB/" title="axios实现12306火车票查询功能 爬虫">axios实现12306火车票查询功能 爬虫</a><time datetime="2021-08-20T14:46:35.000Z" title="发表于 2021-08-20 22:46:35">2021-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/13/Typora%E4%BD%BF%E7%94%A8PicGo-Core%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/" title="Typora使用PicGo-Core插件配置图床"><img src="https://gitee.com/pinkcrow/hexo_img/raw/master/img/image-20210828003249659.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Typora使用PicGo-Core插件配置图床"/></a><div class="content"><a class="title" href="/2021/08/13/Typora%E4%BD%BF%E7%94%A8PicGo-Core%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%9B%BE%E5%BA%8A/" title="Typora使用PicGo-Core插件配置图床">Typora使用PicGo-Core插件配置图床</a><time datetime="2021-08-12T16:51:05.000Z" title="发表于 2021-08-13 00:51:05">2021-08-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Pink Crow</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'UcFpfL2gQAps8CuCCQIg6hBB-gzGzoHsz',
      appKey: 'kRCWNukGYPS9GLMYVSnPw7q7',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/myfix.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>